plot(cluster_result, main = "Dendrogramma per le risposte ai video di happiness")
normalized_frequencies
data_subset <- bais_data[bais_data$emotion == "happiness", ]
# Calcolo delle frequenze
category_frequencies <- table(data_subset$category)
# Normalizzazione delle frequenze
normalized_frequencies <- category_frequencies / sum(category_frequencies)
# Creazione della tabella delle categorie
category_table <- table(data_subset$emotion, data_subset$category)
# Creazione di una matrice di dissimilarità utilizzando la distanza di Jaccard con normalizzazione delle frequenze
diss_matrix <- 1 - proxy::simil(as.matrix(category_table), method = "Jaccard", frequency = normalized_frequencies)
normalized_frequencies
category_table
diss_matrix <- 1 - proxy::simil(as.matrix(category_table), method = "Jaccard", frequency = normalized_frequencies)
diss_matrix
cluster_result <- agnes(diss_matrix, method = "complete")
cluster_result
# Visualizzazione del dendrogramma
plot(cluster_result, main = "Dendrogramma per le risposte ai video di happiness")
Calcolo delle frequenze
# Calcolo delle frequenze
category_frequencies <- table(data_subset$category)
# Normalizzazione delle frequenze
normalized_frequencies <- category_frequencies / sum(category_frequencies)
# Creazione della tabella delle categorie
category_table <- table(data_subset$emotion, data_subset$category)
# Creazione di una matrice di dissimilarità utilizzando la distanza di Jaccard con normalizzazione delle frequenze
diss_matrix <- 1 - proxy::simil(as.matrix(category_table), method = "Jaccard", frequency = normalized_frequencies)
# Creazione del dendrogramma
cluster_result <- hclust(as.dist(diss_matrix), method = "complete")
# Calcolo dei cluster
clusters <- cutree(cluster_result, k = 3)
# Creazione dei dati per il plot
video_rep <- rep(data_subset$video_set, each = length(category_table))
category_rep <- rep(names(category_table), times = length(data_subset$video_set))
cluster_rep <- rep(clusters, each = length(category_table))
cluster_data <- data.frame(video = video_rep, category = category_rep, cluster = cluster_rep)
cluster_data <- data.frame(video = rep(data_subset$video_set, each = length(names(category_table))),
category = rep(names(category_table), times = length(data_subset$video_set)),
cluster = rep(clusters, each = length(names(category_table))))
# Visualizzazione del dendrogramma
plot(cluster_result, main = "Dendrogramma per le risposte ai video di happiness")
# Visualizzazione del plot delle categorie e dei cluster
plot(category ~ video, data = cluster_data, col = cluster, pch = 16,
main = "Plot delle categorie e dei cluster", xlab = "Video", ylab = "Categoria")
# Visualizzazione del plot delle categorie e dei cluster
plot(category ~ video, data = cluster_data, col = cluster, pch = 16,
main = "Plot delle categorie e dei cluster", xlab = "Video", ylab = "Categoria")
cluster_data
cluster_rep
category_rep
video_rep
category_rep <- rep(names(category_table), times = length(data_subset$video_set))
category_rep
# Calcolo delle frequenze delle categorie nel dataset
category_table <- table(data_subset$category)
video_rep <- rep(data_subset$video_set, times = category_table)
# Creazione del dataframe dei dati dei cluster
cluster_data <- data.frame(video = video_rep, category = category_rep, cluster = cluster_rep)
clusters
emotion <- "happiness"
# Filtra il dataset per i video con l'emozione "happiness"
data_subset <- bais_data[bais_data$emotion == emotion, ]
# Calcolo delle frequenze
category_frequencies <- table(data_subset$category)
# Normalizzazione delle frequenze
normalized_frequencies <- category_frequencies / sum(category_frequencies)
# Creazione della tabella delle categorie
category_table <- table(data_subset$emotion, emotion)
table(data_subset$emotion)
normalized_frequencies
data_subset <- bais_data[bais_data$emotion == "happiness", ]
data_subset
category_frequencies <- table(data_subset$category)
category_frequencies
normalized_frequencies <- category_frequencies / sum(category_frequencies)
table(data_subset$emotion, data_subset$category)
# Creazione di una matrice di dissimilarità utilizzando la distanza di Jaccard con normalizzazione delle frequenze
diss_matrix <- 1 - proxy::simil(as.matrix(normalized_frequencies), method = "Jaccard", frequency = normalized_frequencies)
# Esecuzione dell'analisi di cluster utilizzando il metodo agglomerativo completo
cluster_result <- agnes(diss_matrix, method = "complete")
# Visualizzazione del dendrogramma
plot(cluster_result, main = "Dendrogramma per le risposte ai video di happiness")
cluster_result
?agnes
# Esecuzione dell'analisi di cluster utilizzando il metodo agglomerativo completo
cluster_result <- agnes(diss_matrix, method = "weighted")
# Visualizzazione del dendrogramma
plot(cluster_result, main = "Dendrogramma per le risposte ai video di happiness")
cluster_result
# Esecuzione dell'analisi di cluster utilizzando il metodo agglomerativo completo
cluster_result <- agnes(diss_matrix, method = "single")
# Visualizzazione del dendrogramma
plot(cluster_result, main = "Dendrogramma per le risposte ai video di happiness")
data(votes.repub)
force(votes.repub)
agn1 <- agnes(votes.repub, metric = "manhattan", stand = TRUE)
agn1
plot(agn1)
# Caricamento dei pacchetti necessari
library(cluster)
# Preparazione dei dati
data_subset <- subset(dataset, emotion == "happiness")  # Filtra solo le osservazioni con emozione "happiness"
dataset <- bais_data
# Preparazione dei dati
data_subset <- subset(dataset, emotion == "happiness")  # Filtra solo le osservazioni con emozione "happiness"
# Creazione della matrice di dissimilarità
diss_matrix <- proxy::dist(as.matrix(data_subset[, c("video_set", "group", "emotion")]), method = "binary")
# Esecuzione del clustering gerarchico
cluster_result <- hclust(diss_matrix, method = "ward.D2")
data_subset
diss_matrix
x<- diss_matrix
x<- diss_matrix%>%
data.frame
View(x)
data_subset[, c("video_set", "group", "emotion")]
# Creazione della matrice di dissimilarità
diss_matrix <- proxy::dist(as.matrix(data_subset[, c("video_set", "group", "category")]), method = "binary")
diss_matrix
data_subset
proxy::dist(as.matrix(data_subset[, c("video_set", "group", "category")]), method = "binary")
# Preparazione dei dati
data_subset <- subset(dataset, emotion == "happiness")%>%
dplyr::select("video_set", "group", "category")# Filtra solo le osservazioni con emozione "happiness"
# Creazione della matrice di dissimilarità
diss_matrix <- proxy::dist(as.matrix(data_subset[, c("video_set", "group", "category")]), method = "binary")
diss_matrix
as.matrix(data_subset[, c("video_set", "group", "category")])
data_subset <- subset(dataset, emotion == "happiness")%>%
mutate(vars = paste0(video_set, "_",group))%>%
dplyr::select("vars", "category")
category_frequencies <- table(data_subset$category, data_subset$vars )
data_subset <- subset(dataset, emotion == "happiness")%>%
mutate(vars = paste0(video_set, "_",group))%>%
dplyr::select("vars", "category")# Filtra solo le osservazioni con emozione "happiness"
category_frequencies <- table(data_subset$category, data_subset$vars )
diss_matrix <- proxy::dist(as.matrix(category_frequencies), method = "binary")
# Esecuzione del clustering gerarchico
cluster_result <- hclust(diss_matrix, method = "ward.D2")
# Numero di cluster desiderato
num_clusters <- 3
# Assegnazione delle osservazioni ai cluster
clusters <- cutree(cluster_result, k = num_clusters)
# Creazione del dataframe dei dati dei cluster
cluster_data <- data.frame(vars = data_subset$vars,
category = data_subset$category,
cluster = clusters)
cluster_data <- data.frame(vars = rep(data_subset$vars, each = length(names(category_table))),
category = rep(names(category_table), times = length(data_subset$vars)),
cluster = rep(clusters, each = length(names(category_table))))
cluster_data <- data.frame(vars = rep(data_subset$vars, each = length(names(category_table))),
category = rep(names(category_table), times = length(category_table)),
cluster = rep(clusters, each = length(names(category_table))))
vars = rep(data_subset$vars, each = length(names(category_table)))
category = rep(names(category_table), times = length(data_subset$vars))
cluster = rep(clusters, each = length(names(category_table)))
clusters
# Visualizzazione del legame tra variabili e cluster
table(cluster_data$cluster, cluster_data$emotion)
cluster_result
# Numero di cluster desiderato
num_clusters <- 4
clusters <- cutree(cluster_result, k = num_clusters)
cluster_data <- data.frame(vars = data_subset$vars,
category = data_subset$category)
cluster_data <- data.frame(vars = rep(data_subset$vars, each = length(names(category_table))),
category = rep(names(category_table), times = length(data_subset$vars)),
cluster = rep(clusters, each = length(names(category_table))))
library(cluster)
dataset <- bais_data
# Preparazione dei dati
data_subset <- subset(dataset, emotion == "happiness") %>%
mutate(vars = paste0(video_set, "_", group)) %>%
dplyr::select("vars", "category") # Filtra solo le osservazioni con emozione "happiness"
category_table <- table(data_subset$category)
# Creazione della matrice di dissimilarità
diss_matrix <- proxy::dist(as.matrix(category_table), method = "binary")
# Esecuzione del clustering gerarchico
cluster_result <- hclust(diss_matrix, method = "ward.D2")
# Numero di cluster desiderato
num_clusters <- 4
# Assegnazione delle osservazioni ai cluster
clusters <- cutree(cluster_result, k = num_clusters)
# Creazione del dataframe dei dati dei cluster
cluster_data <- data.frame(vars = rep(data_subset$vars, each = length(names(category_table))),
category = rep(names(category_table), times = length(data_subset$vars)),
cluster = rep(clusters, each = length(names(category_table))))
# Creazione del dataframe dei dati dei cluster
category_rep <- rep(names(category_table), each = length(data_subset$vars))
vars_rep <- rep(data_subset$vars, times = length(names(category_table)))
cluster_rep <- rep(clusters, each = length(data_subset$vars) * length(names(category_table)))
cluster_data <- data.frame(vars = vars_rep, category = category_rep, cluster = cluster_rep)
# Plot dei cluster
plot(cluster_data$video, cluster_data$group, col = cluster_data$cluster, pch = 16,
main = "Cluster per il modello happiness ~ video_set * group * emotion",
xlab = "Video", ylab = "Group")
cluster_data
# Plot dei cluster
plot(cluster_data$var, cluster_data$category, col = cluster_data$cluster, pch = 16,
main = "Cluster per il modello happiness ~ video_set * group * emotion",
xlab = "Video", ylab = "Group")
# Plot dei cluster
plot(cluster_data$vars, cluster_data$category, col = cluster_data$cluster, pch = 16,
main = "Cluster per il modello happiness ~ video_set * group * emotion",
xlab = "Video/group", ylab = "emotion")
# Plot dei cluster
plot(cluster_data$vars, cluster_data$category, col = cluster_data$cluster, pch = 16,
main = "Cluster per il modello happiness ~ video_set * group * emotion",
xlab = "Video/group", ylab = "emotion")
cluster_data
sampled_data <- cluster_data %>% sample_n(size = 1000)  # Modifica la dimensione del campione secondo le tue esigenze
# Plot con i dati campionati
plot(sampled_data$vars, sampled_data$category, col = sampled_data$cluster, pch = 16,
main = "Cluster per il modello happiness ~ video_set * group * emotion",
xlab = "Video/group", ylab = "emotion")
plot(cluster, main = "Dendrogramma del clustering gerarchico",
xlab = "Osservazioni", ylab = "Distanza")
cluster_result <- hclust(diss_matrix, method = "ward.D2")
plot(cluster_result, main = "Dendrogramma del clustering gerarchico",
xlab = "Osservazioni", ylab = "Distanza")
dataset <- bais_data
# Preparazione dei dati
data_subset <- subset(dataset, emotion == "happiness")%>%
mutate(vars = paste0(video_set, "_",group))%>%
dplyr::select("vars", "category")# Filtra solo le osservazioni con emozione "happiness"
category_frequencies <- table(data_subset$category, data_subset$vars )
# Creazione della matrice di dissimilarità
diss_matrix <- proxy::dist(as.matrix(category_frequencies), method = "binary")
# Esecuzione del clustering gerarchico
cluster_result <- hclust(diss_matrix, method = "ward.D2")
plot(cluster_result, main = "Dendrogramma del clustering gerarchico",
xlab = "Osservazioni", ylab = "Distanza")
diss_matrix
cluster_result <- agnes(diss_matrix, method = "complete")
cluster_result
# Visualizzazione del dendrogramma
plot(cluster_result, main = "Dendrogramma per le risposte ai video di happiness")
###########################################################################
#
#  Experiment:  CARIPARO
#  Programmer:  QUETTIER THOMAS
#  Date:        0382022
#     This script performs data analysis for the CARIPARO experiment,
#     specifically for the uncertainty and bais measures of the MBScontrol experiment.
#     It computes datasets, generates plots, tables, and fits a
#     mixed-effects model to analyze the uncertaunty and bais.
#
#  Experiment   MBScontrol
#
#  Update:      23/05/2023
###########################################################################
rm(list=ls()) # remove all objects
# Functions & libraries---------------------------------------------------------------
devtools::load_all()
# Data --------------------------------------------------------------------
load(file.path("objects","mbs_circular.RData"))
error<-correct_data%>%
filter(Resp.correct == 0)%>%
group_by(subject, group, emotion, video_set, category) %>%
summarise(bais = n())
correct_data <-  dataset_gw1 %>%
dplyr::select(Pt.code,  Video.set, Video.emotion, Pt.group, Resp.category, Resp.correct) %>%
'colnames<-'(c("subject" ,"video_set", "emotion", "group", "category","correct"))%>%
filter(subject != "10_moebius") # no match
error<-correct_data%>%
filter(Resp.correct == 0)%>%
group_by(subject, group, emotion, video_set, category) %>%
summarise(bais = n())
error<-correct_data%>%
filter(correct == 0)%>%
group_by(subject, group, emotion, video_set, category) %>%
summarise(bais = n())
View(error)
error <- correct_data %>%
filter(correct == 0) %>%
group_by(subject, group, emotion, video_set, category) %>%
summarise(bais = n()) %>%
group_by(group, emotion, video_set, category) %>%
summarise(bais = mean(bais))
summarise(error)
summarise(error$bais)
summary(error$bais)
8/15
error <- correct_data %>%
filter(correct == 0)
table(error$emotion,error$category)
53/18
error <- correct_data %>%
filter(correct == 0) %>%
group_by(subject, group, emotion, video_set, category) %>%
summarise(bais = n()) %>%
group_by(group, emotion, video_set, category) %>%
summarise(bais = mean(bais))
?chisq.test
## From Agresti(2007) p.39
M <- as.table(rbind(c(762, 327, 468), c(484, 239, 477)))
dimnames(M) <- list(gender = c("F", "M"),
party = c("Democrat","Independent", "Republican"))
(Xsq <- chisq.test(M))  # Prints test summary
Xsq$observed   # observed counts (same as M)
Xsq$expected   # expected counts under the null
Xsq$residuals  # Pearson residuals
Xsq$stdres     # standardized residuals
M
as.table(rbind(c(762, 327, 468), c(484, 239, 477)))
test <- error %>%
filter( group == "moebius" & emotion == "hapiness")
View(test)
test <- error %>%
filter( group == "moebius" & emotion == "happiness")
test <- error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE")
View(test)
test <- error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "ADFES")
test <- error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE")%>%
mutate(expected = 15/1)
test
test <- error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE")%>%
mutate(expected = 1/15)
chisq.test(table(test$bais, test$expected))
error <- correct_data %>%
filter(correct == 0) %>%
group_by(subject, group, emotion, video_set, category) %>%
summarise(bais = n()) %>%
group_by(group, emotion, video_set, category) %>%
summarise(bais = mean(bais),
expected = 1/15)
chisq.test(table(test$bais, test$expected))
test <- error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE")%>%
select(bais,expected)
chisq.test(test)
test <- error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE")%>%
select(bais,expected)
test
test <- error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE") %>%
select( bais, expected)
test
test <- error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE") %>%
select( "bais", "expected")
test
test <- error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE") %>%
data.frame() %>%
select( "bais", "expected")
test
test <- error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE") %>%
data.frame() %>%
select( "bais", "expected") %>%
'rownames<-'(c(category))
test <- error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE") %>%
data.frame() %>%
'rownames<-'(c(category)) %>%
select( "bais", "expected")
error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE") %>%
data.frame()
error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE") %>%
data.frame() %>%
'rownames<-'(c(category))
rownames()
error %>%
'rownames<-'(c(category))
error
c(category)
test <- error %>%
has_rownames(category) %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE") %>%
data.frame()
test <- error %>%
has_rownames(.,category)
test <- error %>%
has_rownames(error$category)
error %>%
`rownames<-`(category)
error %>%
`rownames<-`(.,category)
error %>%
tibble::column_to_rownames(var = "category")
test <- error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE") %>%
data.frame() %>%
tibble::column_to_rownames(var = "category") %>%
select( "bais", "expected")
test
error <- correct_data %>%
filter(correct == 0) %>%
group_by(subject, group, emotion, video_set, category) %>%
summarise(bais = n()) %>%
group_by(group, emotion, video_set, category) %>%
summarise(bais = bais/18,
expected = 1/15)
error
test <- error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE") %>%
data.frame() %>%
tibble::column_to_rownames(var = "category") %>%
select( "bais", "expected")
error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE") %>%
data.frame(
)
error <- correct_data %>%
filter(correct == 0) %>%
group_by(subject, group, emotion, video_set, category) %>%
summarise(bais = n()) %>%
group_by(group, emotion, video_set, category) %>%
summarise(bais = bais/18,
bais = mean(bais),
expected = 1/15)
test <- error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE") %>%
data.frame() %>%
tibble::column_to_rownames(var = "category") %>%
select( "bais", "expected")
correct_data %>%
filter(correct == 0) %>%
group_by(subject, group, emotion, video_set, category) %>%
summarise(bais = n()) %>%
group_by(group, emotion, video_set, category)
error <- correct_data %>%
filter(correct == 0) %>%
group_by(subject, group, emotion, video_set, category) %>%
summarise(bais = n()) %>%
group_by(group, emotion, video_set, category) %>%
summarise(bais = bais/18,
expected = 1/15)
error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE") %>%
data.frame()
error <- correct_data %>%
filter(correct == 0) %>%
group_by(subject, group, emotion, video_set, category) %>%
summarise(bais = n())
error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE") %>%
data.frame()
error <- correct_data %>%
filter(correct == 0) %>%
group_by(subject, group, emotion, video_set, category) %>%
summarise(bais = n()) %>%
group_by(group, emotion, video_set, category) %>%
summarise(bais = sum(bais)/18,
expected = 1/15)
error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE") %>%
data.frame()
test <- error %>%
filter( group == "moebius" & emotion == "happiness" & video_set == "JeFEE") %>%
data.frame() %>%
tibble::column_to_rownames(var = "category") %>%
select( "bais", "expected")
test
chisq.test(test)
library(vcd)
install.packages("vcd")
?mosaic
mosaic(~ bais + expected,
data = test,
shade = TRUE
)
library(vcd)
mosaic(~ bais + expected,
data = test,
shade = TRUE
)
test <- error %>%
filter( group == "moebius" & emotion == "fear" & video_set == "JeFEE") %>%
data.frame() %>%
tibble::column_to_rownames(var = "category") %>%
select( "bais", "expected")
test <- error %>%
filter( group == "moebius" & emotion == "fear" & video_set == "JeFEE") %>%
data.frame() %>%
tibble::column_to_rownames(var = "category") %>%
select( "bais", "expected")
mosaic(~ bais + expected,
data = test,
shade = TRUE
)
chisq.test(test)
ggbarstats(
data = test,
x = bais,
y = expected
) +
labs(caption = NULL)
library(ggstatsplot)
library(ggplot2)
install.packages("ggstatsplot")
library(ggstatsplot)
ggbarstats(
data = test,
x = bais,
y = expected
) +
labs(caption = NULL)
library(vcd)
library(ggstatsplot)
> install.packages("ggstatsplot")
install.packages("ggstatsplot")
library(ggstatsplot)
